---
title: 'Investigating large datasets in R'
author: "Data Carpentry Contributors"
teaching: 
exercises: 
questions:
objectives: 
- Explore a large dataset graphically
- Develop simple models with `lm()`
- Choose new packages and interpret package descriptions
- Analyze complex models using Information Theoretic (IT) Model Averaging (`arm` and `MuMIn` packages)
keypoints: 
- 
source: Rmd
---
```{r setup, message = FALSE, warning = FALSE, echo = FALSE}
library(tidyverse)
library(arm)
library(MuMIn)

source("../bin/chunk-options.R")
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
knitr_fig_path("05-")

phys_data<-read.csv("data/Physiology_Environmental_Data.csv")
```
### Setup
Let's begin by loading the data and packages necessary to start this lesson.
```{r load-package-data}
# Load packages
library(ggplot2)

# Load data
phys_data<-read.csv("data/Physiology_Environmental_Data.csv")
```


### How to Work with Complex Models: IT Model Averaging

```{r global-model}
# Global model
fit_all <- lm(Trmmol_night ~ (VPD_N + TAIR_N + Soil_moisture + Fgroup)^2, data=phys_data)
```


```{r, load-packages}
# Load packages
library(arm)
library(MuMIn)
```

First, let's standardize our input variables with the `standardize()` function in the `arm` package. `standardize()` rescales numeric variables that take on more than two values to have a mean of 0 and a standard deviation of 0.5. To do this, we just need to specify the object to standardize (our global model, `fit_all`):
```{r standardize-global-model, eval = TRUE}
#{r standardize-global-model, eval = FALSE}
# Standardize the global model

stdz.model<-standardize(fit_all)
summary(stdz.model)
```

Next, we create the full submodel set with the `dredge()` function in the `MuMIn` package by specifying the object that `dredge()` will evaluate (our standardized model, `stdz.model`). We also need to change the default "na.omit" to prevent models from being fitted to different datasets in case of missing values using `options(na.action=na.fail) `:
```{r options-model-set, eval = TRUE}
#{r options-model-set, eval = FALSE}
options(na.action=na.fail) 
model.set<-dredge(stdz.model)
```

The `get.models()` function will then create a top model set. First, we need to specify the object that `get.models` will evaluate (our model set, `model.set`), and then we need to specify the subset of models to include all models within 4AICcs with `subset=delta<4`:
```{r top-models, eval = FALSE}
top.models<-get.models(model.set, subset=delta<4)
top.models
```

Finally, we'll use the `model.avg()` function to create our average model and calculates relative importance. We need to specify the object that `model.avg()` will evaluate (in this case our top model set, `top.models`):
```{r ave-model, eval = FALSE}
average_model<-model.avg(top.models)
```

To check out our final average model, use the `summary()` function:
```{r summary-model, eval = FALSE} 
summary(average_model)
```

This is a lot of information! We can see which component models were chosen as the top model set and then averaged, as well as their associated ranking information. We can also see the model-averaged coefficients for both the full average model and conditional average model.

The *conditional average* only averages over the models where the parameter appears. Conversely, the *full average* assumes that a variable is included in every model, but in some models the corresponding coefficient (and its respective variance) is set to zero. Unlike the *conditional average*, the *full average* does not bias the value away from zero.

We can also check out the relative importance of each factor within the model with the `importance()` function. Relative importance is a unitless metric ranging from 0 (doesn't contribute to the model at all) to 1 (contributes heavily to the model). This function will also give use the number of models within the top model set that contain each factor.
```{r importance, eval = FALSE}
importance(average_model)
```


> ## Challenge 4
> Using IT Model Averaging, create a model that tests for the effects of four factors on either transpiration or stomatal conductance. Then, create a plot that best illustrates the main finding of your top model. Ultimately, your results should be able to address one of these questions:
>
> - What environmental variables drive nocturnal transpiration / stomatal conductance, and do these differ from the drivers of daytime transpiration / stomatal conductance?
> - Are nocturnal transpiration and stomatal conductance associated with daytime physiological processes?
{: .challenge}


